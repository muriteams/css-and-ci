---
title: "CSS Analysis"
author: "George G. Vega Yon"
date: "October 22, 2018"
output:
  pdf_document:
    keep_tex: true
    md_extensions: "+autolink_bare_uris+ascii_identifiers+tex_math_single_backslash+raw_tex"
header-includes:
  - \usepackage{pdflscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
---

<!-- Default sans serif -->
\renewcommand{\familydefault}{\sfdefault} 


# Locally Aggregated Structures (LAS)

*   For each group $g \in G$ we generated what the literature calls Locally Aggregated Structure networks (LAS networks).

*   A tie $(i,j)$ in the LAS exists if and only if $(i,j) \in CSS_i$ and $(i,j) \in CSS_j$, i.e. if both $i$ and $j$ report the existance of such tie.

```{r setup, message=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, message = FALSE, autodep = -1L)
library(similR)
library(igraph)
stats_labels <- c(
  `Hamman (S)`  = "shamann",
  `Hamming (D)` = "dhamming",
  `Mean Manhattan (D)` = "dmh",
  `Michael (S)` = "smichael",
  `Sized Difference (D)` = "dsd"
  )
```

```{r data, echo=FALSE}
# Reading covariate data
dat_group <- haven::read_spss("../data-raw/MURI_AllSurveys - FINAL - Group level data_1.sav")
dat_individual <- 
  haven::read_spss("../data-raw/MURI_AllSurveys - FINAL_073018.sav")
dat_individual$Group <- as.integer(dat_individual$Group) 
```

```{r network-data, echo=FALSE}
# Reading raw daa
networks_truth      <- readRDS("../data/networks_advice_las.rds")  # readRDS("../data/networks_truth.rds")[["3"]]$advice
networks_advice_css <- readRDS("../data/networks_advice_css.rds")
networks_sizes      <- readr::read_csv("../data-raw/Study1_Group sizes.csv")
```

# Percieved network vs LAS

In this set of the analysis, we compare each individual's perception of the true
with generated by the Locally Aggregated Structures (LAS). This way, for each
group, we have $n_g$ different statistics.

```{r cssdata1, echo=FALSE, eval = TRUE}
# Calculating distances/similarity of true advice network vs CSS
css_rangeL <- lapply(names(networks_advice_css), function(n) {
  
  similR::similarity(
    c(list(networks_truth[[n]]), networks_advice_css[[n]]),
    statistic  = stats_labels,
    normalized = FALSE,
    firstonly  = TRUE,
    exclude_j  = TRUE
  )
  
})
names(css_rangeL) <- names(networks_advice_css)

# Computing range
library(data.table)

# Ranges, min and max within groups
dat_las <- vector("list", length(css_rangeL))
names(dat_las) <- names(css_rangeL)

for (i in seq_along(dat_las)) {
  dat_las[[i]] <- data.table(css_rangeL[[i]])
  dat_las[[i]] <- melt(
    dat_las[[i]][, ..stats_labels],
    measure.vars  = stats_labels,
    variable.name = "statistic"
    )
  dat_las[[i]] <- dat_las[[i]][, list(
    range = diff(range(value)),
    max   = max(value),
    min   = min(value)
    ), by = "statistic"]
  dat_las[[i]] <- dcast(dat_las[[i]],  . ~ statistic, value.var = c("range", "max", "min"))
  dat_las[[i]]$. <- NULL
  dat_las[[i]]$Group <- names(css_rangeL)[i]
}

dat_las <- rbindlist(dat_las)

# Getting the group size
networks_sizes$Group <- as.character(networks_sizes$Group)
dat_las <- merge(dat_las, networks_sizes, by = "Group")
```


```{r violin-plot-las, fig.cap="Distribution of Within Group Ranges of Similarity (S) and Distance (D) Statistics with respect to the LAS. Values are normalized to range between 0 and 1."}
library(ggplot2)

are_stats <- setdiff(colnames(dat_las), c("Group", "groupSize"))
dat_las_long <- rbindlist(lapply(are_stats, function(idx) {
  
  # Appending
  ans <- subset(dat_las, select = c("Group", "groupSize", idx))
  
  # Labels
  colnames(ans)[3] <- "Value"
  ans$Statistic <- gsub(".+_", "", idx)
  ans$Type      <- gsub("_.+", "", idx)
  
  # Returning
  ans
  }))

# Rescaling from 0-1
dat_las_long[, Value := (Value - min(Value))/diff(range(Value)), by = c("Statistic", "Type")]
dat_las_long$`Group size` <- as.character(dat_las_long$groupSize)

# nicer names
dat_las_long[, Statistic := names(stats_labels)[match(Statistic, stats_labels)]]

ggplot(subset(dat_las_long, Type == "range"), aes(x = Statistic, y = Value)) +
  geom_violin() +
  geom_jitter(height = 0, width=.1, aes(colour=`Group size`, shape = `Group size`), size=4) +
  scale_colour_viridis_d(alpha = .7) +
  ylab("Value (scaled between 0 and 1)") +
  theme(axis.text = element_text(angle = 45, hjust = 1))
```


```{r corrplot-las, fig.cap="Correlation levels between different measurements of matrix distance or correlation comparing individuals' perception of the network with LAS."}
correlations_las <- cor(subset(dat_las, select = grepl("^range", colnames(dat_las))))
dimnames(correlations_las) <- lapply(dimnames(correlations_las), function(n) {
  n <- gsub("^range_", "", n)
  names(stats_labels)[match(n, stats_labels)]
})

correlations_las <- data.table(correlations_las, keep.rownames = TRUE)
correlations_las <- melt(correlations_las, id.vars = "rn")

ggplot(correlations_las, mapping = aes(x = rn, y = variable, fill = value)) +
  geom_tile() +
  theme(axis.text = element_text(angle = 45, hjust = 1)) +
  scale_fill_viridis_c() +
  labs(y="", x="")
```

Observation: The hamming normalized seems to be the same as the Mean manhattan (s)

# Percieved $i$ vs percieved $j$

In this case, instead of comparing each individuals' perception with the LAS,
we compare perceptions between individuals. This measurement will be somewhat
biased since, in order to be able to fully compare $j$ and $i$'s perception of
the network, we include what they report about their own ties, this is, $j$ and
$i$'s perception of themselves.

```{r cssdata-within, echo=FALSE, eval=TRUE}
# Filling the gaps: we need to add i's perception if itself to the networks
# so that we can make a full comparison, otherwise, comparisons would reduce
# to only 2 or 3 cases, which is too few.
groups_ids <- unique(names(networks_advice_css))

networks_advice_css_filled <- networks_advice_css
for (g in groups_ids) {
  
  # Adding i's perception from the true network data
  for (i in names(networks_advice_css[[g]])) 
    networks_advice_css_filled[[g]][[i]][i,] <- networks_truth[[g]][i,]
  
}

# Calculating distances/similarity of true advice network vs CSS
css_range_within <- lapply(names(networks_advice_css), function(n) {
  
  similR::similarity(
    networks_advice_css_filled[[n]],
    statistic  = stats_labels,
    normalized = FALSE,
    firstonly  = FALSE,
    exclude_j  = FALSE
  )
  
})

names(css_range_within) <- names(networks_advice_css)

# Ranges
dat_within <- vector("list", length(css_range_within))
names(dat_within) <- names(css_range_within)

for (i in seq_along(dat_within)) {
  dat_within[[i]] <- data.table(css_range_within[[i]])
  dat_within[[i]] <- melt(
    dat_within[[i]][, ..stats_labels],
    measure.vars  = stats_labels,
    variable.name = "statistic"
    )
  dat_within[[i]] <- dat_within[[i]][, list(
    range = diff(range(value)),
    max   = max(value),
    min   = min(value)
    ), by = "statistic"]
  dat_within[[i]] <- dcast(dat_within[[i]],  . ~ statistic, value.var = c("range", "max", "min"))
  dat_within[[i]]$. <- NULL
  dat_within[[i]]$Group <- names(css_rangeL)[i]
}

dat_within <- rbindlist(dat_within)

# Getting the group size
networks_sizes$Group <- as.character(networks_sizes$Group)
dat_within <- merge(dat_within, networks_sizes, by = "Group")

```


```{r violin-plot-within, fig.cap="Distribution of Within Group Ranges of Similarity (S) and Distance (D) Statistics comparing $i$ vs $j$ perception of the network. Values are normalized to range between 0 and 1."}
are_stats <- setdiff(colnames(dat_within), c("Group", "groupSize"))
dat_within_long <- rbindlist(lapply(are_stats, function(idx) {
  
  # Appending
  ans <- subset(dat_within, select = c("Group", "groupSize", idx))
  
  # Labels
  colnames(ans)[3] <- "Value"
  ans$Statistic <- gsub(".+_", "", idx)
  ans$Type      <- gsub("_.+", "", idx)
  
  # Returning
  ans
  }))

# Rescaling from 0-1
dat_within_long[, Value := (Value - min(Value))/diff(range(Value)), by = c("Statistic", "Type")]
dat_within_long$`Group size` <- as.character(dat_within_long$groupSize)

# nicer names
dat_within_long[, Statistic := names(stats_labels)[match(Statistic, stats_labels)]]

ggplot(subset(dat_within_long, Type == "range"), aes(x = Statistic, y = Value)) +
  geom_violin() +
  geom_jitter(height = 0, width=.1, aes(colour=`Group size`, shape = `Group size`), size=4) +
  scale_colour_viridis_d(alpha = .7) +
  ylab("Value (scaled between 0 and 1)") +
  theme(axis.text = element_text(angle = 45, hjust = 1))
```


```{r corrplot-within, fig.cap="Correlation levels between different measurements of matrix distance or correlation comparing individuals' perception of the network with LAS."}
correlations_within <- cor(subset(dat_within, select = grepl("^range", colnames(dat_within))))
dimnames(correlations_within) <- lapply(dimnames(correlations_within), function(n) {
  n <- gsub("^range_", "", n)
  names(stats_labels)[match(n, stats_labels)]
})

correlations_within <- data.table(correlations_within, keep.rownames = TRUE)
correlations_within <- melt(correlations_within, id.vars = "rn")

ggplot(correlations_within, mapping = aes(x = rn, y = variable, fill = value)) +
  geom_tile() +
  theme(axis.text = element_text(angle = 45, hjust = 1)) +
  scale_fill_viridis_c() +
  labs(y="", x="")
```

# Association with collective intelligence

```{r model-data}
# List of variables to run regressions
tci_variables <- c("CI_avg.T1", "CI_avg.T2")
covariates    <- c("GrpProportionMale", "GrpRangeAge", "GrpProportionNonwhite",
                   "GrpSize", "GPA_AVG")
```


## LAS

```{r model-data-las}
# Regrouping the css_range
model_data <- dat_las[, .SD, .SDcols = patterns("^(range|Group)")]
dat_group$Group <- as.character(dat_group$Group)
model_data <- merge(model_data, dat_group, by = "Group") 
```

Descriptive statistics

```{r eval=FALSE, fig.cap="Descriptive Statistics "}
sum_stats <- melt(
  data         = model_data,
  id.vars      = c("Group", "GrpSize"),
  measure.vars = paste0("range_", stats_labels)
  )

# Nicer names
sum_stats$variable <- names(stats_labels)[
  match(gsub("range_", "", sum_stats$variable), stats_labels)
]

sum_stats <- sum_stats[
  ,
  .(
    `Mean (SD)` = sprintf("%.2f (%.2f)", mean(value), sd(value)),
    `Range`     = sprintf("[%.2f, %.2f]", min(value), max(value))
    ),
  by = "variable"
  ]
knitr::kable(sum_stats)
```


```{r full-model}
mnum <- 0L
models <- vector("list", 0)
for (s in paste0("range_", stats_labels)) {
  
  m <- paste("`CI_avg.T2` ~ GrpProportionMale + GrpRangeAge + GrpProportionNonwhite + 
             GPA_AVG + factor(GrpSize)+",s)
  models[[mnum <- mnum + 1]] <- lm(as.formula(m), data = model_data)
  
}
```

```{r full-model-less03}

model_data <- model_data[GrpSize != 3L]
colnames(model_data)[colnames(model_data) == "CI_avg.T2"] <- "CI_avg.T2(-3)"

for (s in paste0("range_", stats_labels)) {
  
  m <- paste("`CI_avg.T2(-3)` ~ GrpProportionMale + GrpRangeAge + GrpProportionNonwhite + 
             GPA_AVG + factor(GrpSize)+",s)
  models[[mnum <- mnum + 1]] <- lm(as.formula(m), data = model_data)
  
}
```

\clearpage 

\blandscape

```{r table, results='asis'}
# Generating the table
tabfun <- if (knitr::is_html_output()) {
  texreg::htmlreg
  } else {
    function(...) texreg::texreg(...)
  }

# How many variables that are not statistics
ncovars <- length(setdiff(names(models[[1]]$coefficients), paste0("range_", stats_labels))) + 1L

tab <- capture.output(tabfun(
  models,
  # dep.var.labels   = c("All groups", "Groups of size 4 and 5"),
  # dep.var.caption  = "Standarized TCI",
  custom.coef.map = c(list(
    "GrpProportionMale"= "Prop. of Males" ,
    "GrpProportionNonwhite" = "Prop. of Non-white",
    "GrpRangeAge"      = "Age Range" ,
    "GPA_AVG"          = "Avg GPA",
    "factor(GrpSize)4" = "Size = 4" , 
    "factor(GrpSize)5" = "Size = 5" ,
    "(Intercept)"      = "(Intercept)"
    ), structure(names(stats_labels), names = paste0("range_", stats_labels))
    ),
  groups  = list(
    "Distance/Similarity" = ncovars:(ncovars + length(stats_labels) - 1)),
  caption = "Regression using different distance/similarity measurements"
  ))

cat(tab, sep="\n")
```

\elandscape

\clearpage 

\normalsize


## Within


```{r model-data-within}
# Regrouping the css_range
model_data <- dat_within[, .SD, .SDcols = patterns("^(range|Group)")]
# dat_group$Group <- as.character(dat_group$Group)
model_data <- merge(model_data, dat_group, by = "Group") 
```

```{r full-model-within}
mnum <- 0L
models <- vector("list", 0)
for (s in paste0("range_", stats_labels)) {
  
  m <- paste("`CI_avg.T2` ~ GrpProportionMale + GrpRangeAge + GrpProportionNonwhite + 
             GPA_AVG + factor(GrpSize)+",s)
  models[[mnum <- mnum + 1]] <- lm(as.formula(m), data = model_data)
  
}
```

```{r full-model-less03-within}

model_data <- model_data[GrpSize != 3L]
colnames(model_data)[colnames(model_data) == "CI_avg.T2"] <-"CI_avg.T2(-3)"

for (s in paste0("range_", stats_labels)) {
  
  m <- paste("`CI_avg.T2(-3)` ~ GrpProportionMale + GrpRangeAge + GrpProportionNonwhite + 
             GPA_AVG + factor(GrpSize)+",s)
  models[[mnum <- mnum + 1]] <- lm(as.formula(m), data = model_data)
  
}
```

\clearpage 

\blandscape

```{r table-within, results='asis'}
# Generating the table
tabfun <- if (knitr::is_html_output()) {
  texreg::htmlreg
  } else {
    function(...) texreg::texreg(...)
  }

# How many variables that are not statistics
ncovars <- length(setdiff(names(models[[1]]$coefficients), paste0("range_", stats_labels))) + 1L

tab <- capture.output(tabfun(
  models,
  # dep.var.labels   = c("All groups", "Groups of size 4 and 5"),
  # dep.var.caption  = "Standarized TCI",
  custom.coef.map = c(list(
    "GrpProportionMale"= "Prop. of Males" ,
    "GrpProportionNonwhite" = "Prop. of Non-white",
    "GrpRangeAge"      = "Age Range" ,
    "GPA_AVG"          = "Avg GPA",
    "factor(GrpSize)4" = "Size = 4" , 
    "factor(GrpSize)5" = "Size = 5" ,
    "(Intercept)"      = "(Intercept)"
    ), structure(names(stats_labels), names = paste0("range_", stats_labels))
    ),
  groups  = list(
    "Distance/Similarity" = ncovars:(ncovars + length(stats_labels) - 1)),
  caption = "Regression using different distance/similarity measurements"
  ))

cat(tab, sep="\n")
```

\elandscape

\clearpage 

\normalsize


# Network plots


```{r plot-graph-3, fig.cap="LAS Networks of size 3", echo=FALSE, results='hide'}
networks_size3 <- networks_truth[networks_sizes$groupSize==3] %>%
  lapply(igraph::graph_from_adjacency_matrix)

nnetworks_size3 <- length(networks_size3)
op <- par(mfrow=c(3,3), mai=rep(.2, 4))
lapply(networks_size3, plot, vertex.size=10, vertex.label="", edge.arrow.size=.5)
par(op)
```

```{r plot-graph-4, fig.cap="LAS Networks of size 4.", echo=FALSE, results='hide'}
networks_size4 <- networks_truth[networks_sizes$groupSize==4] %>%
  lapply(., igraph::graph_from_adjacency_matrix)

nnetworks_size4 <- length(networks_size4)
op <- par(mfrow=c(4,5), mai=rep(.2, 4))
lapply(networks_size4, plot, vertex.size=10, vertex.label="")
par(op)
```


```{r plot-graph-5, fig.cap="LAS Networks of size 5.", echo=FALSE, results='hide'}
networks_size5 <- networks_truth[networks_sizes$groupSize==5] %>%
  lapply(., igraph::graph_from_adjacency_matrix)

nnetworks_size5 <- length(networks_size5)
op <- par(mfrow=c(4,5), mai=rep(.2, 4))
lapply(networks_size5, plot, vertex.size=10, vertex.label="")
par(op)
```

<!-- # Factor analysis -->

<!-- ```{r analysis} -->
<!-- dat_individual %>% -->
<!--   select( -->
<!--     PID, Group, -->
<!--     RMEscore, -->
<!--     SI3Fac1, SI3Fac2, SI3Fac3, -->
<!--     # ZRMEscore, ZFLAbRel, -->
<!--     FL_absolute_avg -->
<!--     ) -->
<!-- ``` -->


Look if non-linear associations better fit?

Last step, see if the individual level accuracy relates to other domains of intelligence.


